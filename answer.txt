### 批改结果（基于 `question.txt` 中最新题目）

#### 1. `count_vowels_per_word`
- **结果**: 部分正确
- **问题**:
  - 函数名与你题目要求的 `count_vowels_per_word` 应一致（你写的是 `count_vowelsPer_word`）。
  - 当前实现以原始分词作为字典键（`sentence.split()` 会把 `example.` 作为一个词），但题目示例期望去掉标点。建议去除两端非字母数字字符后再作为键。
- **改进建议**:
  ```python
  import string

  def count_vowels_per_word(sentence: str) -> dict[str, int]:
      vowels = set('aeiou')
      result = {}
      for word in sentence.split():
          key = word.strip(string.punctuation)
          count = sum(1 for ch in key.lower() if ch in vowels)
          result[key] = count
      return result
  ```

#### 2. `fibonacci_sequence` (题目要求名为 `fibonacci_recursive`)
- **结果**: 错误
- **问题**:
  - 基本边界条件反了（`if n == 0: return [0]` 与 `if n == 1: return [0,1]` 不符合题意）。
  - 函数内部调用拼写错误：`finonacci_sequence`（拼写）导致 NameError。
  - 题目要求递归实现并说明避免重复计算的思路（例如备忘录），但当前实现没有备注也没有优化。
- **改进实现（递归 + 备忘录）**:
  ```python
  def fibonacci_recursive(n: int, _memo: dict[int, list[int]] | None = None) -> list[int]:
      if n <= 0:
          return []
      if _memo is None:
          _memo = {}
      if n in _memo:
          return _memo[n]
      if n == 1:
          _memo[1] = [0]
          return _memo[1]
      if n == 2:
          _memo[2] = [0, 1]
          return _memo[2]
      prev = fibonacci_recursive(n - 1, _memo)
      _memo[n] = prev + [prev[-1] + prev[-2]]
      return _memo[n]
  ```
  - 在函数文档或注释中说明：使用 `_memo` 字典缓存已计算的前 k 项，避免重复子问题计算。

#### 3. `char_frequency`
- **结果**: 未实现
- **要求回顾**: 忽略非字母数字字符，统计时不区分大小写，但返回键应为首次出现的原始大小写形式，且按首次出现顺序排列。
- **示例实现**:
  ```python
  def char_frequency(s: str) -> dict[str, int]:
      lower_to_key: dict[str, str] = {}
      counts: dict[str, int] = {}
      for ch in s:
          if not ch.isalnum():
              continue
          lower = ch.lower()
          if lower not in lower_to_key:
              lower_to_key[lower] = ch  # 保留首次出现的原始形式
              counts[lower] = 0
          counts[lower] += 1
      # 构造按首次出现顺序的结果 dict
      result: dict[str, int] = {}
      for lower, orig in lower_to_key.items():
          result[orig] = counts[lower]
      return result
  ```

#### 4. `subtract_fractions`
- **结果**: 部分正确
- **问题**: 你的实现直接把传入的数据交给 `Fraction`，但 `Fraction` 不接受 `(num, den)` 形式的 tuple 作为单个参数。需要处理字符串和 tuple 两种输入格式，并做输入验证（例如分母不为 0）。
- **改进实现**:
  ```python
  from fractions import Fraction
  from typing import Union, Tuple

  def _to_fraction(val: Union[str, Tuple[int,int]]) -> Fraction:
      if isinstance(val, tuple):
          return Fraction(val[0], val[1])
      return Fraction(val)

  def subtract_fractions(fraction1: Union[str, Tuple[int,int]], fraction2: Union[str, Tuple[int,int]]) -> str:
      f1 = _to_fraction(fraction1)
      f2 = _to_fraction(fraction2)
      res = f1 - f2
      return f"{res.numerator}/{res.denominator}"
  ```

#### 5. `word_length_distribution`
- **结果**: 部分正确
- **问题**:
  - 当 `max_len` 为 `None` 时，`len_word <= max_len` 会报错（None 与 int 比较）。
  - 当单词经过滤后长度为 0（例如纯标点）应当跳过，不应计入分布。
- **改进实现**:
  ```python
  from collections import defaultdict

  def word_length_distribution(sentence: str, min_len: int = 0, max_len: int | None = None) -> dict[int, int]:
      res = defaultdict(int)
      for word in sentence.split():
          length = sum(1 for ch in word if ch.isalnum())
          if length == 0:
              continue
          if length < min_len:
              continue
          if max_len is not None and length > max_len:
              continue
          res[length] += 1
      return dict(res)
  ```

### 总结得分
- **已实现且通过或部分正确**: `count_vowels_per_word` (部分)、`subtract_fractions` (部分)、`word_length_distribution` (部分)
- **需补全/修正**: `fibonacci_recursive`（重写并加入备忘录说明）、`char_frequency`（未实现）

### 建议你追加到 `review.txt` 的新知识点
- 递归 + 备忘录（避免重复计算）
- 参数类型兼容与输入验证（`isinstance`）
- 利用字典保留插入顺序以满足“首次出现形式”约束

如果你愿意，我可以：
- 代为修正 `lab.py` 中的函数并运行现有测试；或
- 只生成更详细的测试集合 `tests/test_*.py` 来验证每个函数的行为。
### 批改结果

#### 1. count_vowels_per_word
- **结果**: 正确
- **优点**: 使用了集合 `vowels` 和字典推导式，代码简洁高效。
- **建议**: 可以在注释中说明元音字母的定义（大小写是否敏感）。

#### 2. fibonacci_recursive
- **结果**: 错误
- **问题**: `fibonacci[n-1]` 是无效的语法，且递归调用中重复计算导致效率低下。
- **改进**:
  ```python
  def fibonacci_recursive(n: int) -> list[int]:
      if n == 1:
          return [0]
      if n == 2:
          return [0, 1]
      seq = fibonacci_recursive(n-1)
      return seq + [seq[-1] + seq[-2]]
  ```

#### 3. char_frequency
- **结果**: 错误
- **问题**: 列表推导式中 `char.isalnum()` 的语法错误。
- **改进**:
  ```python
  def char_frequency(s: str) -> dict[str, int]:
      chars = [char for char in s if char.isalnum()]
      return Counter(chars)
  ```

#### 4. subtract_fraction
- **结果**: 错误
- **问题**: 模块名错误，应为 `fractions` 而非 `fraction`。
- **改进**:
  ```python
  from fractions import Fraction
  def subtract_fraction(fraction1: str, fraction2: str) -> str:
      frac = Fraction(fraction1) - Fraction(fraction2)
      return f"{frac.numerator}/{frac.denominator}"
  ```

#### 5. word_length_distribution
- **结果**: 正确
- **优点**: 使用了 `defaultdict` 和 `filter`，逻辑清晰。
- **建议**: 可以在注释中说明 `filter` 的作用。

### 总结
- **正确答案**: 2/5
- **新知识点**:
  1. 递归的正确实现方式，避免重复计算。
  2. `fractions` 模块的正确导入方式。
  3. 列表推导式中条件过滤的正确语法。

请将以下内容追加到 `review.txt`：
- 递归的优化（避免重复计算）。
- `fractions` 模块的使用。
- 列表推导式中的条件过滤。